// Licensed under the Apache-2.0 license.
//
// generated by caliptra_registers_generator with rtl-caliptra repo at f1feedff601b55715ccaed60ebfcd83543617752
//
#![allow(clippy::erasing_op)]
#![allow(clippy::identity_op)]
#[derive(Clone, Copy)]
pub struct RegisterBlock(*mut u32);
impl RegisterBlock {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    pub unsafe fn new(ptr: *mut u32) -> Self {
        Self(ptr)
    }
    pub fn sha512_reg() -> Self {
        unsafe { Self::new(0x10020000 as *mut u32) }
    }
    /// Two 32-bit read-only registers repereseting of the name
    /// of SHA512 component. These registers are located at
    /// SHA512_base_address + 0x0000_0000 and 0x0000_0004 addresses.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn name(&self) -> ureg::Array<2, ureg::RegRef<crate::sha512::meta::Name>> {
        unsafe { ureg::Array::new(self.0.wrapping_add(0 / core::mem::size_of::<u32>())) }
    }
    /// Two 32-bit read-only registers repereseting of the version
    /// of SHA512 component. These registers are located at
    /// SHA512_base_address + 0x0000_0008 and 0x0000_000C addresses.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn version(&self) -> ureg::Array<2, ureg::RegRef<crate::sha512::meta::Version>> {
        unsafe { ureg::Array::new(self.0.wrapping_add(8 / core::mem::size_of::<u32>())) }
    }
    /// One 4-bit register including the following flags:
    /// bit #0: INIT : Trigs the SHA512 core to start the
    ///                processing for the first padded message block.
    /// bit #1: NEXT: ​Trigs the SHA512 core to start the
    ///                processing for the remining padded message block.
    /// bit #3-2: MODE : Indicates the SHA512 core to set dynamically
    ///                 the type of hashing algorithm. This can be:
    ///                 00 for SHA512/224
    ///                 01 for SHA512/256
    ///                 10 for SHA384
    ///                 11 for SHA512
    /// This register is located at SHA512_base_address + 0x0000_0010
    /// After each software write, hardware will erase the register.
    ///
    /// Read value: [`sha512::regs::CtrlReadVal`]; Write value: [`sha512::regs::CtrlWriteVal`]
    pub fn ctrl(&self) -> ureg::RegRef<crate::sha512::meta::Ctrl> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x10 / core::mem::size_of::<u32>())) }
    }
    /// One 2-bit register including the following flags:
    /// bit #0: READY : ​Indicates if the core is ready to take
    ///                a control command and process the block.  
    /// bit #1: Valid: ​Indicates if the process is done and the
    ///                hash value stored in DIGEST registers is valid.
    /// This register is located at SHA512_base_address + 0x0000_0018.
    ///
    /// Read value: [`sha512::regs::StatusReadVal`]; Write value: [`sha512::regs::StatusWriteVal`]
    pub fn status(&self) -> ureg::RegRef<crate::sha512::meta::Status> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x18 / core::mem::size_of::<u32>())) }
    }
    /// 32 32-bit registers storing the 1024-bit padded input.
    /// These registers are located at SHA512_base_address +
    /// 0x0000_0080 to 0x0000_00FC in big-endian representation.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn block(&self) -> ureg::Array<32, ureg::RegRef<crate::sha512::meta::Block>> {
        unsafe { ureg::Array::new(self.0.wrapping_add(0x80 / core::mem::size_of::<u32>())) }
    }
    /// 16 32-bit registers storing the 512-bit digest output.
    /// These registers are located at SHA512_base_address +
    /// 0x0000_0100 to 0x0000_013C in big-endian representation.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn digest(&self) -> ureg::Array<16, ureg::RegRef<crate::sha512::meta::Digest>> {
        unsafe { ureg::Array::new(self.0.wrapping_add(0x100 / core::mem::size_of::<u32>())) }
    }
    /// Controls the Key Vault read access for this engine
    ///
    /// Read value: [`sha512::regs::KvReadCtrlRegReadVal`]; Write value: [`sha512::regs::KvReadCtrlRegWriteVal`]
    pub fn kv_rd_ctrl(&self) -> ureg::RegRef<crate::sha512::meta::KvRdCtrl> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x600 / core::mem::size_of::<u32>())) }
    }
    /// Controls the Key Vault write access for this engine
    ///
    /// Read value: [`sha512::regs::KvWriteCtrlRegReadVal`]; Write value: [`sha512::regs::KvWriteCtrlRegWriteVal`]
    pub fn kv_wr_ctrl(&self) -> ureg::RegRef<crate::sha512::meta::KvWrCtrl> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x604 / core::mem::size_of::<u32>())) }
    }
}
pub mod regs {
    //! Types that represent the values held by registers.
    #[derive(Clone, Copy)]
    pub struct CtrlWriteVal(u32);
    impl CtrlWriteVal {
        /// Control init command bit
        #[inline(always)]
        pub fn init(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Control next command bit
        #[inline(always)]
        pub fn next(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        /// Control mode command bits
        #[inline(always)]
        pub fn mode(self, val: u32) -> Self {
            Self((self.0 & !(3 << 2)) | ((val & 3) << 2))
        }
    }
    impl From<u32> for CtrlWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CtrlWriteVal> for u32 {
        fn from(val: CtrlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StatusReadVal(u32);
    impl StatusReadVal {
        /// Status ready bit
        #[inline(always)]
        pub fn ready(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Status valid bit
        #[inline(always)]
        pub fn valid(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
    }
    impl From<u32> for StatusReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StatusReadVal> for u32 {
        fn from(val: StatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct KvReadCtrlRegReadVal(u32);
    impl KvReadCtrlRegReadVal {
        /// Indicates that the read data is to come from the key vault.
        /// Setting this bit to 1 initiates copying of data from the key vault.
        #[inline(always)]
        pub fn read_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Key Vault entry to retrieve the read data from for the engine
        #[inline(always)]
        pub fn read_entry(&self) -> u32 {
            (self.0 >> 1) & 7
        }
        /// Entry selected is a PCR slot
        #[inline(always)]
        pub fn entry_is_pcr(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Size of the source data for SHA512 and HMAC384 Block only.
        /// This field is ignored for all other reads.
        /// Size is encoded as N-1 dwords.
        /// KV flow will pad the 1024 Block data and append the length for values 0-26.
        /// All 0 data and Length must be appended in the next Block for values 27-31.
        ///                       
        /// 5'd7 - 256b of data
        ///                       
        /// 5'd11 - 384b of data
        ///                       
        /// 5'd15 - 512b of data
        #[inline(always)]
        pub fn entry_data_size(&self) -> u32 {
            (self.0 >> 5) & 0x1f
        }
        /// Reserved field
        #[inline(always)]
        pub fn rsvd(&self) -> u32 {
            (self.0 >> 10) & 0x1fffff
        }
        /// Result has been copied from the key vault
        #[inline(always)]
        pub fn read_done(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> KvReadCtrlRegWriteVal {
            KvReadCtrlRegWriteVal(self.0)
        }
    }
    impl From<u32> for KvReadCtrlRegReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<KvReadCtrlRegReadVal> for u32 {
        fn from(val: KvReadCtrlRegReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct KvReadCtrlRegWriteVal(u32);
    impl KvReadCtrlRegWriteVal {
        /// Indicates that the read data is to come from the key vault.
        /// Setting this bit to 1 initiates copying of data from the key vault.
        #[inline(always)]
        pub fn read_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Key Vault entry to retrieve the read data from for the engine
        #[inline(always)]
        pub fn read_entry(self, val: u32) -> Self {
            Self((self.0 & !(7 << 1)) | ((val & 7) << 1))
        }
        /// Entry selected is a PCR slot
        #[inline(always)]
        pub fn entry_is_pcr(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Size of the source data for SHA512 and HMAC384 Block only.
        /// This field is ignored for all other reads.
        /// Size is encoded as N-1 dwords.
        /// KV flow will pad the 1024 Block data and append the length for values 0-26.
        /// All 0 data and Length must be appended in the next Block for values 27-31.
        ///                       
        /// 5'd7 - 256b of data
        ///                       
        /// 5'd11 - 384b of data
        ///                       
        /// 5'd15 - 512b of data
        #[inline(always)]
        pub fn entry_data_size(self, val: u32) -> Self {
            Self((self.0 & !(0x1f << 5)) | ((val & 0x1f) << 5))
        }
        /// Reserved field
        #[inline(always)]
        pub fn rsvd(self, val: u32) -> Self {
            Self((self.0 & !(0x1fffff << 10)) | ((val & 0x1fffff) << 10))
        }
    }
    impl From<u32> for KvReadCtrlRegWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<KvReadCtrlRegWriteVal> for u32 {
        fn from(val: KvReadCtrlRegWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct KvWriteCtrlRegReadVal(u32);
    impl KvWriteCtrlRegReadVal {
        /// Indicates that the result is to be stored in the key vault.
        /// Setting this bit to 1 will copy the result to the keyvault when it is ready.
        #[inline(always)]
        pub fn write_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Key Vault entry to store the result
        #[inline(always)]
        pub fn write_entry(&self) -> u32 {
            (self.0 >> 1) & 7
        }
        /// Destination selected is a PCR slot
        #[inline(always)]
        pub fn entry_is_pcr(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// HMAC KEY is a valid destination
        #[inline(always)]
        pub fn hmac_key_dest_valid(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// HMAC BLOCK is a valid destination
        #[inline(always)]
        pub fn hmac_block_dest_valid(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// SHA BLOCK is a valid destination
        #[inline(always)]
        pub fn sha_block_dest_valid(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        /// ECC PKEY is a valid destination
        #[inline(always)]
        pub fn ecc_pkey_dest_valid(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        /// ECC SEED is a valid destination
        #[inline(always)]
        pub fn ecc_seed_dest_valid(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        /// ECC MSG is a valid destination
        #[inline(always)]
        pub fn ecc_msg_dest_valid(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// Reserved field
        #[inline(always)]
        pub fn rsvd(&self) -> u32 {
            (self.0 >> 11) & 0xfffff
        }
        /// Result has been copied to key vault
        #[inline(always)]
        pub fn write_done(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> KvWriteCtrlRegWriteVal {
            KvWriteCtrlRegWriteVal(self.0)
        }
    }
    impl From<u32> for KvWriteCtrlRegReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<KvWriteCtrlRegReadVal> for u32 {
        fn from(val: KvWriteCtrlRegReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct KvWriteCtrlRegWriteVal(u32);
    impl KvWriteCtrlRegWriteVal {
        /// Indicates that the result is to be stored in the key vault.
        /// Setting this bit to 1 will copy the result to the keyvault when it is ready.
        #[inline(always)]
        pub fn write_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Key Vault entry to store the result
        #[inline(always)]
        pub fn write_entry(self, val: u32) -> Self {
            Self((self.0 & !(7 << 1)) | ((val & 7) << 1))
        }
        /// Destination selected is a PCR slot
        #[inline(always)]
        pub fn entry_is_pcr(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// HMAC KEY is a valid destination
        #[inline(always)]
        pub fn hmac_key_dest_valid(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// HMAC BLOCK is a valid destination
        #[inline(always)]
        pub fn hmac_block_dest_valid(self, val: bool) -> Self {
            Self((self.0 & !(1 << 6)) | (u32::from(val) << 6))
        }
        /// SHA BLOCK is a valid destination
        #[inline(always)]
        pub fn sha_block_dest_valid(self, val: bool) -> Self {
            Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
        }
        /// ECC PKEY is a valid destination
        #[inline(always)]
        pub fn ecc_pkey_dest_valid(self, val: bool) -> Self {
            Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
        }
        /// ECC SEED is a valid destination
        #[inline(always)]
        pub fn ecc_seed_dest_valid(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        /// ECC MSG is a valid destination
        #[inline(always)]
        pub fn ecc_msg_dest_valid(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
        /// Reserved field
        #[inline(always)]
        pub fn rsvd(self, val: u32) -> Self {
            Self((self.0 & !(0xfffff << 11)) | ((val & 0xfffff) << 11))
        }
    }
    impl From<u32> for KvWriteCtrlRegWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<KvWriteCtrlRegWriteVal> for u32 {
        fn from(val: KvWriteCtrlRegWriteVal) -> u32 {
            val.0
        }
    }
}
pub mod enums {
    //! Enumerations used by some register fields.
    pub mod selector {}
}
pub mod meta {
    //! Additional metadata needed by ureg.
    #[derive(Clone, Copy)]
    pub struct Name();
    impl ureg::RegType for Name {
        type Raw = u32;
    }
    impl ureg::ReadableReg for Name {
        type ReadVal = u32;
    }
    #[derive(Clone, Copy)]
    pub struct Version();
    impl ureg::RegType for Version {
        type Raw = u32;
    }
    impl ureg::ReadableReg for Version {
        type ReadVal = u32;
    }
    #[derive(Clone, Copy)]
    pub struct Ctrl();
    impl ureg::RegType for Ctrl {
        type Raw = u32;
    }
    impl ureg::WritableReg for Ctrl {
        type WriteVal = crate::sha512::regs::CtrlWriteVal;
    }
    impl ureg::ResettableReg for Ctrl {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct Status();
    impl ureg::RegType for Status {
        type Raw = u32;
    }
    impl ureg::ReadableReg for Status {
        type ReadVal = crate::sha512::regs::StatusReadVal;
    }
    #[derive(Clone, Copy)]
    pub struct Block();
    impl ureg::RegType for Block {
        type Raw = u32;
    }
    impl ureg::WritableReg for Block {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for Block {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct Digest();
    impl ureg::RegType for Digest {
        type Raw = u32;
    }
    impl ureg::ReadableReg for Digest {
        type ReadVal = u32;
    }
    #[derive(Clone, Copy)]
    pub struct KvRdCtrl();
    impl ureg::RegType for KvRdCtrl {
        type Raw = u32;
    }
    impl ureg::ReadableReg for KvRdCtrl {
        type ReadVal = crate::sha512::regs::KvReadCtrlRegReadVal;
    }
    impl ureg::WritableReg for KvRdCtrl {
        type WriteVal = crate::sha512::regs::KvReadCtrlRegWriteVal;
    }
    impl ureg::ResettableReg for KvRdCtrl {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct KvWrCtrl();
    impl ureg::RegType for KvWrCtrl {
        type Raw = u32;
    }
    impl ureg::ReadableReg for KvWrCtrl {
        type ReadVal = crate::sha512::regs::KvWriteCtrlRegReadVal;
    }
    impl ureg::WritableReg for KvWrCtrl {
        type WriteVal = crate::sha512::regs::KvWriteCtrlRegWriteVal;
    }
    impl ureg::ResettableReg for KvWrCtrl {
        const RESET_VAL: Self::Raw = 0;
    }
}
