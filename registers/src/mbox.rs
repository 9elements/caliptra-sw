// Licensed under the Apache-2.0 license.
//
// generated by caliptra_registers_generator with rtl-caliptra repo at f1feedff601b55715ccaed60ebfcd83543617752
//
#![allow(clippy::erasing_op)]
#![allow(clippy::identity_op)]
#[derive(Clone, Copy)]
pub struct RegisterBlock(*mut u32);
impl RegisterBlock {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    pub unsafe fn new(ptr: *mut u32) -> Self {
        Self(ptr)
    }
    pub fn mbox_csr() -> Self {
        unsafe { Self::new(0x30020000 as *mut u32) }
    }
    /// Mailbox lock register for mailbox access, reading 0 will set the lock
    ///
    /// Read value: [`mbox::regs::LockReadVal`]; Write value: [`mbox::regs::LockWriteVal`]
    pub fn lock(&self) -> ureg::RegRef<crate::mbox::meta::Lock> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0 / core::mem::size_of::<u32>())) }
    }
    /// Stores the user that locked the mailbox
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn user(&self) -> ureg::RegRef<crate::mbox::meta::User> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(4 / core::mem::size_of::<u32>())) }
    }
    /// Command requested for data in mailbox
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cmd(&self) -> ureg::RegRef<crate::mbox::meta::Cmd> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(8 / core::mem::size_of::<u32>())) }
    }
    /// Data length for mailbox access
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn dlen(&self) -> ureg::RegRef<crate::mbox::meta::Dlen> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0xc / core::mem::size_of::<u32>())) }
    }
    /// Data in register, write the next data to mailbox
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn datain(&self) -> ureg::RegRef<crate::mbox::meta::Datain> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x10 / core::mem::size_of::<u32>())) }
    }
    /// Data out register, read the next data from mailbox
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn dataout(&self) -> ureg::RegRef<crate::mbox::meta::Dataout> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x14 / core::mem::size_of::<u32>())) }
    }
    /// Mailbox execute register indicates to receiver that the sender is done
    ///
    /// Read value: [`mbox::regs::ExecuteReadVal`]; Write value: [`mbox::regs::ExecuteWriteVal`]
    pub fn execute(&self) -> ureg::RegRef<crate::mbox::meta::Execute> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x18 / core::mem::size_of::<u32>())) }
    }
    /// Status of the mailbox command
    ///
    /// Read value: [`mbox::regs::StatusReadVal`]; Write value: [`mbox::regs::StatusWriteVal`]
    pub fn status(&self) -> ureg::RegRef<crate::mbox::meta::Status> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x1c / core::mem::size_of::<u32>())) }
    }
}
pub mod regs {
    //! Types that represent the values held by registers.
    #[derive(Clone, Copy)]
    pub struct ExecuteReadVal(u32);
    impl ExecuteReadVal {
        ///
        #[inline(always)]
        pub fn execute(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> ExecuteWriteVal {
            ExecuteWriteVal(self.0)
        }
    }
    impl From<u32> for ExecuteReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ExecuteReadVal> for u32 {
        fn from(val: ExecuteReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ExecuteWriteVal(u32);
    impl ExecuteWriteVal {
        ///
        #[inline(always)]
        pub fn execute(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for ExecuteWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ExecuteWriteVal> for u32 {
        fn from(val: ExecuteWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct LockReadVal(u32);
    impl LockReadVal {
        ///
        #[inline(always)]
        pub fn lock(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
    }
    impl From<u32> for LockReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<LockReadVal> for u32 {
        fn from(val: LockReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StatusReadVal(u32);
    impl StatusReadVal {
        /// Indicates the status of mailbox command
        #[inline(always)]
        pub fn status(&self) -> super::enums::MboxStatusE {
            super::enums::MboxStatusE::try_from((self.0 >> 0) & 3).unwrap()
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> StatusWriteVal {
            StatusWriteVal(self.0)
        }
    }
    impl From<u32> for StatusReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StatusReadVal> for u32 {
        fn from(val: StatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StatusWriteVal(u32);
    impl StatusWriteVal {
        /// Indicates the status of mailbox command
        #[inline(always)]
        pub fn status(
            self,
            f: impl FnOnce(super::enums::selector::MboxStatusESelector) -> super::enums::MboxStatusE,
        ) -> Self {
            Self(
                (self.0 & !(3 << 0))
                    | (u32::from(f(super::enums::selector::MboxStatusESelector())) << 0),
            )
        }
    }
    impl From<u32> for StatusWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StatusWriteVal> for u32 {
        fn from(val: StatusWriteVal) -> u32 {
            val.0
        }
    }
}
pub mod enums {
    //! Enumerations used by some register fields.
    #[derive(Clone, Copy, Eq, PartialEq)]
    #[repr(u32)]
    pub enum MboxStatusE {
        CmdBusy = 0,
        DataReady = 1,
        CmdComplete = 2,
        CmdFailure = 3,
    }
    impl MboxStatusE {
        #[inline(always)]
        pub fn cmd_busy(&self) -> bool {
            *self == Self::CmdBusy
        }
        #[inline(always)]
        pub fn data_ready(&self) -> bool {
            *self == Self::DataReady
        }
        #[inline(always)]
        pub fn cmd_complete(&self) -> bool {
            *self == Self::CmdComplete
        }
        #[inline(always)]
        pub fn cmd_failure(&self) -> bool {
            *self == Self::CmdFailure
        }
    }
    impl TryFrom<u32> for MboxStatusE {
        type Error = ();
        #[inline(always)]
        fn try_from(val: u32) -> Result<MboxStatusE, ()> {
            match val {
                0 => Ok(Self::CmdBusy),
                1 => Ok(Self::DataReady),
                2 => Ok(Self::CmdComplete),
                3 => Ok(Self::CmdFailure),
                _ => Err(()),
            }
        }
    }
    impl From<MboxStatusE> for u32 {
        fn from(val: MboxStatusE) -> Self {
            val as u32
        }
    }
    pub mod selector {
        pub struct MboxStatusESelector();
        impl MboxStatusESelector {
            #[inline(always)]
            pub fn cmd_busy(&self) -> super::MboxStatusE {
                super::MboxStatusE::CmdBusy
            }
            #[inline(always)]
            pub fn data_ready(&self) -> super::MboxStatusE {
                super::MboxStatusE::DataReady
            }
            #[inline(always)]
            pub fn cmd_complete(&self) -> super::MboxStatusE {
                super::MboxStatusE::CmdComplete
            }
            #[inline(always)]
            pub fn cmd_failure(&self) -> super::MboxStatusE {
                super::MboxStatusE::CmdFailure
            }
        }
    }
}
pub mod meta {
    //! Additional metadata needed by ureg.
    #[derive(Clone, Copy)]
    pub struct Lock();
    impl ureg::RegType for Lock {
        type Raw = u32;
    }
    impl ureg::ReadableReg for Lock {
        type ReadVal = crate::mbox::regs::LockReadVal;
    }
    #[derive(Clone, Copy)]
    pub struct User();
    impl ureg::RegType for User {
        type Raw = u32;
    }
    impl ureg::ReadableReg for User {
        type ReadVal = u32;
    }
    #[derive(Clone, Copy)]
    pub struct Cmd();
    impl ureg::RegType for Cmd {
        type Raw = u32;
    }
    impl ureg::ReadableReg for Cmd {
        type ReadVal = u32;
    }
    impl ureg::WritableReg for Cmd {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for Cmd {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct Dlen();
    impl ureg::RegType for Dlen {
        type Raw = u32;
    }
    impl ureg::ReadableReg for Dlen {
        type ReadVal = u32;
    }
    impl ureg::WritableReg for Dlen {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for Dlen {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct Datain();
    impl ureg::RegType for Datain {
        type Raw = u32;
    }
    impl ureg::ReadableReg for Datain {
        type ReadVal = u32;
    }
    impl ureg::WritableReg for Datain {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for Datain {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct Dataout();
    impl ureg::RegType for Dataout {
        type Raw = u32;
    }
    impl ureg::ReadableReg for Dataout {
        type ReadVal = u32;
    }
    impl ureg::WritableReg for Dataout {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for Dataout {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct Execute();
    impl ureg::RegType for Execute {
        type Raw = u32;
    }
    impl ureg::ReadableReg for Execute {
        type ReadVal = crate::mbox::regs::ExecuteReadVal;
    }
    impl ureg::WritableReg for Execute {
        type WriteVal = crate::mbox::regs::ExecuteWriteVal;
    }
    impl ureg::ResettableReg for Execute {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct Status();
    impl ureg::RegType for Status {
        type Raw = u32;
    }
    impl ureg::ReadableReg for Status {
        type ReadVal = crate::mbox::regs::StatusReadVal;
    }
    impl ureg::WritableReg for Status {
        type WriteVal = crate::mbox::regs::StatusWriteVal;
    }
    impl ureg::ResettableReg for Status {
        const RESET_VAL: Self::Raw = 0;
    }
}
