// Licensed under the Apache-2.0 license.
//
// generated by caliptra_registers_generator with rtl-caliptra repo at f1feedff601b55715ccaed60ebfcd83543617752
//
#![allow(clippy::erasing_op)]
#![allow(clippy::identity_op)]
#[derive(Clone, Copy)]
pub struct RegisterBlock(*mut u32);
impl RegisterBlock {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    pub unsafe fn new(ptr: *mut u32) -> Self {
        Self(ptr)
    }
    pub fn hmac_reg() -> Self {
        unsafe { Self::new(0x10010000 as *mut u32) }
    }
    /// Two 32-bit read-only registers repereseting of the name
    /// of HMAC384 component. These registers are located at
    /// HMAC384_base_address + 0x0000_0000 and 0x0000_0004 addresses.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn name(&self) -> ureg::Array<2, ureg::RegRef<crate::hmac::meta::Name>> {
        unsafe { ureg::Array::new(self.0.wrapping_add(0 / core::mem::size_of::<u32>())) }
    }
    /// Two 32-bit read-only registers repereseting of the version
    /// of HMAC384 component. These registers are located at
    /// HMAC384_base_address + 0x0000_0008 and 0x0000_000C addresses.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn version(&self) -> ureg::Array<2, ureg::RegRef<crate::hmac::meta::Version>> {
        unsafe { ureg::Array::new(self.0.wrapping_add(8 / core::mem::size_of::<u32>())) }
    }
    /// One 2-bit register including the following flags:
    /// bit #0: INIT : Trigs the HMAC384 core to start the
    ///                processing for the key and the first padded
    ///                message block.
    /// bit #1: NEXT: ​Trigs the HMAC384 core to start the
    ///                processing for the remining padded message block.
    /// This register is located at HMAC384_base_address + 0x0000_0010
    /// After each software write, hardware will erase the register.
    ///
    /// Read value: [`hmac::regs::CtrlReadVal`]; Write value: [`hmac::regs::CtrlWriteVal`]
    pub fn ctrl(&self) -> ureg::RegRef<crate::hmac::meta::Ctrl> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x10 / core::mem::size_of::<u32>())) }
    }
    /// One 2-bit register including the following flags:
    /// bit #0: READY : ​Indicates if the core is ready to take
    ///                a control command and process the block.  
    /// bit #1: Valid: ​Indicates if the process is done and the
    ///                results stored in TAG registers are valid.
    /// This register is located at HMAC384_base_address + 0x0000_0018.
    ///
    /// Read value: [`hmac::regs::StatusReadVal`]; Write value: [`hmac::regs::StatusWriteVal`]
    pub fn status(&self) -> ureg::RegRef<crate::hmac::meta::Status> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x18 / core::mem::size_of::<u32>())) }
    }
    /// 12 32-bit registers storing the 384-bit key.
    /// These registers are located at HMAC384_base_address +
    /// 0x0000_0040 to 0x0000_006C in big-endian representation.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn key(&self) -> ureg::Array<12, ureg::RegRef<crate::hmac::meta::Key>> {
        unsafe { ureg::Array::new(self.0.wrapping_add(0x40 / core::mem::size_of::<u32>())) }
    }
    /// 32 32-bit registers storing the 1024-bit padded input.
    /// These registers are located at HMAC384_base_address +
    /// 0x0000_0080 to 0x0000_00FC in big-endian representation.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn block(&self) -> ureg::Array<32, ureg::RegRef<crate::hmac::meta::Block>> {
        unsafe { ureg::Array::new(self.0.wrapping_add(0x80 / core::mem::size_of::<u32>())) }
    }
    /// 12 32-bit registers storing the 384-bit digest output.
    /// These registers are located at HMAC384_base_address +
    /// 0x0000_0100 to 0x0000_012C in big-endian representation.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn tag(&self) -> ureg::Array<12, ureg::RegRef<crate::hmac::meta::Tag>> {
        unsafe { ureg::Array::new(self.0.wrapping_add(0x100 / core::mem::size_of::<u32>())) }
    }
    /// Controls the Key Vault read access for this engine
    ///
    /// Read value: [`hmac::regs::KvRdReadVal`]; Write value: [`hmac::regs::KvRdWriteVal`]
    pub fn kv_rd_key_ctrl(&self) -> ureg::RegRef<crate::hmac::meta::KvRdKeyCtrl> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x600 / core::mem::size_of::<u32>())) }
    }
    /// Controls the Key Vault read access for this engine
    ///
    /// Read value: [`hmac::regs::KvRdReadVal`]; Write value: [`hmac::regs::KvRdWriteVal`]
    pub fn kv_rd_block_ctrl(&self) -> ureg::RegRef<crate::hmac::meta::KvRdBlockCtrl> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x604 / core::mem::size_of::<u32>())) }
    }
    /// Controls the Key Vault write access for this engine
    ///
    /// Read value: [`hmac::regs::KvWrCtrlReadVal`]; Write value: [`hmac::regs::KvWrCtrlWriteVal`]
    pub fn kv_wr_ctrl(&self) -> ureg::RegRef<crate::hmac::meta::KvWrCtrl> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x608 / core::mem::size_of::<u32>())) }
    }
}
pub mod regs {
    //! Types that represent the values held by registers.
    #[derive(Clone, Copy)]
    pub struct CtrlWriteVal(u32);
    impl CtrlWriteVal {
        /// Control init command bit
        #[inline(always)]
        pub fn init(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Control next command bit
        #[inline(always)]
        pub fn next(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
    }
    impl From<u32> for CtrlWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CtrlWriteVal> for u32 {
        fn from(val: CtrlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct KvRdReadVal(u32);
    impl KvRdReadVal {
        /// Indicates that the read data is to come from the key vault.
        /// Setting this bit to 1 initiates copying of data from the key vault.
        #[inline(always)]
        pub fn read_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Key Vault entry to retrieve the read data from for the engine
        #[inline(always)]
        pub fn read_entry(&self) -> u32 {
            (self.0 >> 1) & 7
        }
        /// Entry selected is a PCR slot
        #[inline(always)]
        pub fn entry_is_pcr(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Size of the source data for SHA512 and HMAC384 Block only.
        /// This field is ignored for all other reads.
        /// Size is encoded as N-1 dwords.
        /// KV flow will pad the 1024 Block data and append the length for values 0-26.
        /// All 0 data and Length must be appended in the next Block for values 27-31.
        ///                       
        /// 5'd7 - 256b of data
        ///                       
        /// 5'd11 - 384b of data
        ///                       
        /// 5'd15 - 512b of data
        #[inline(always)]
        pub fn entry_data_size(&self) -> u32 {
            (self.0 >> 5) & 0x1f
        }
        /// Reserved field
        #[inline(always)]
        pub fn rsvd(&self) -> u32 {
            (self.0 >> 10) & 0x1fffff
        }
        /// Result has been copied from the key vault
        #[inline(always)]
        pub fn read_done(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> KvRdWriteVal {
            KvRdWriteVal(self.0)
        }
    }
    impl From<u32> for KvRdReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<KvRdReadVal> for u32 {
        fn from(val: KvRdReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct KvRdWriteVal(u32);
    impl KvRdWriteVal {
        /// Indicates that the read data is to come from the key vault.
        /// Setting this bit to 1 initiates copying of data from the key vault.
        #[inline(always)]
        pub fn read_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Key Vault entry to retrieve the read data from for the engine
        #[inline(always)]
        pub fn read_entry(self, val: u32) -> Self {
            Self((self.0 & !(7 << 1)) | ((val & 7) << 1))
        }
        /// Entry selected is a PCR slot
        #[inline(always)]
        pub fn entry_is_pcr(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// Size of the source data for SHA512 and HMAC384 Block only.
        /// This field is ignored for all other reads.
        /// Size is encoded as N-1 dwords.
        /// KV flow will pad the 1024 Block data and append the length for values 0-26.
        /// All 0 data and Length must be appended in the next Block for values 27-31.
        ///                       
        /// 5'd7 - 256b of data
        ///                       
        /// 5'd11 - 384b of data
        ///                       
        /// 5'd15 - 512b of data
        #[inline(always)]
        pub fn entry_data_size(self, val: u32) -> Self {
            Self((self.0 & !(0x1f << 5)) | ((val & 0x1f) << 5))
        }
        /// Reserved field
        #[inline(always)]
        pub fn rsvd(self, val: u32) -> Self {
            Self((self.0 & !(0x1fffff << 10)) | ((val & 0x1fffff) << 10))
        }
    }
    impl From<u32> for KvRdWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<KvRdWriteVal> for u32 {
        fn from(val: KvRdWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct KvWrCtrlReadVal(u32);
    impl KvWrCtrlReadVal {
        /// Indicates that the result is to be stored in the key vault.
        /// Setting this bit to 1 will copy the result to the keyvault when it is ready.
        #[inline(always)]
        pub fn write_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Key Vault entry to store the result
        #[inline(always)]
        pub fn write_entry(&self) -> u32 {
            (self.0 >> 1) & 7
        }
        /// Destination selected is a PCR slot
        #[inline(always)]
        pub fn entry_is_pcr(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// HMAC KEY is a valid destination
        #[inline(always)]
        pub fn hmac_key_dest_valid(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        /// HMAC BLOCK is a valid destination
        #[inline(always)]
        pub fn hmac_block_dest_valid(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// SHA BLOCK is a valid destination
        #[inline(always)]
        pub fn sha_block_dest_valid(&self) -> bool {
            ((self.0 >> 7) & 1) != 0
        }
        /// ECC PKEY is a valid destination
        #[inline(always)]
        pub fn ecc_pkey_dest_valid(&self) -> bool {
            ((self.0 >> 8) & 1) != 0
        }
        /// ECC SEED is a valid destination
        #[inline(always)]
        pub fn ecc_seed_dest_valid(&self) -> bool {
            ((self.0 >> 9) & 1) != 0
        }
        /// ECC MSG is a valid destination
        #[inline(always)]
        pub fn ecc_msg_dest_valid(&self) -> bool {
            ((self.0 >> 10) & 1) != 0
        }
        /// Reserved field
        #[inline(always)]
        pub fn rsvd(&self) -> u32 {
            (self.0 >> 11) & 0xfffff
        }
        /// Result has been copied to key vault
        #[inline(always)]
        pub fn write_done(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> KvWrCtrlWriteVal {
            KvWrCtrlWriteVal(self.0)
        }
    }
    impl From<u32> for KvWrCtrlReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<KvWrCtrlReadVal> for u32 {
        fn from(val: KvWrCtrlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct KvWrCtrlWriteVal(u32);
    impl KvWrCtrlWriteVal {
        /// Indicates that the result is to be stored in the key vault.
        /// Setting this bit to 1 will copy the result to the keyvault when it is ready.
        #[inline(always)]
        pub fn write_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Key Vault entry to store the result
        #[inline(always)]
        pub fn write_entry(self, val: u32) -> Self {
            Self((self.0 & !(7 << 1)) | ((val & 7) << 1))
        }
        /// Destination selected is a PCR slot
        #[inline(always)]
        pub fn entry_is_pcr(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
        }
        /// HMAC KEY is a valid destination
        #[inline(always)]
        pub fn hmac_key_dest_valid(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
        }
        /// HMAC BLOCK is a valid destination
        #[inline(always)]
        pub fn hmac_block_dest_valid(self, val: bool) -> Self {
            Self((self.0 & !(1 << 6)) | (u32::from(val) << 6))
        }
        /// SHA BLOCK is a valid destination
        #[inline(always)]
        pub fn sha_block_dest_valid(self, val: bool) -> Self {
            Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
        }
        /// ECC PKEY is a valid destination
        #[inline(always)]
        pub fn ecc_pkey_dest_valid(self, val: bool) -> Self {
            Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
        }
        /// ECC SEED is a valid destination
        #[inline(always)]
        pub fn ecc_seed_dest_valid(self, val: bool) -> Self {
            Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
        }
        /// ECC MSG is a valid destination
        #[inline(always)]
        pub fn ecc_msg_dest_valid(self, val: bool) -> Self {
            Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
        }
        /// Reserved field
        #[inline(always)]
        pub fn rsvd(self, val: u32) -> Self {
            Self((self.0 & !(0xfffff << 11)) | ((val & 0xfffff) << 11))
        }
    }
    impl From<u32> for KvWrCtrlWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<KvWrCtrlWriteVal> for u32 {
        fn from(val: KvWrCtrlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StatusReadVal(u32);
    impl StatusReadVal {
        /// Status ready bit
        #[inline(always)]
        pub fn ready(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Status valid bit
        #[inline(always)]
        pub fn valid(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
    }
    impl From<u32> for StatusReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<StatusReadVal> for u32 {
        fn from(val: StatusReadVal) -> u32 {
            val.0
        }
    }
}
pub mod enums {
    //! Enumerations used by some register fields.
    pub mod selector {}
}
pub mod meta {
    //! Additional metadata needed by ureg.
    #[derive(Clone, Copy)]
    pub struct Name();
    impl ureg::RegType for Name {
        type Raw = u32;
    }
    impl ureg::ReadableReg for Name {
        type ReadVal = u32;
    }
    #[derive(Clone, Copy)]
    pub struct Version();
    impl ureg::RegType for Version {
        type Raw = u32;
    }
    impl ureg::ReadableReg for Version {
        type ReadVal = u32;
    }
    #[derive(Clone, Copy)]
    pub struct Ctrl();
    impl ureg::RegType for Ctrl {
        type Raw = u32;
    }
    impl ureg::WritableReg for Ctrl {
        type WriteVal = crate::hmac::regs::CtrlWriteVal;
    }
    impl ureg::ResettableReg for Ctrl {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct Status();
    impl ureg::RegType for Status {
        type Raw = u32;
    }
    impl ureg::ReadableReg for Status {
        type ReadVal = crate::hmac::regs::StatusReadVal;
    }
    #[derive(Clone, Copy)]
    pub struct Key();
    impl ureg::RegType for Key {
        type Raw = u32;
    }
    impl ureg::WritableReg for Key {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for Key {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct Block();
    impl ureg::RegType for Block {
        type Raw = u32;
    }
    impl ureg::WritableReg for Block {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for Block {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct Tag();
    impl ureg::RegType for Tag {
        type Raw = u32;
    }
    impl ureg::ReadableReg for Tag {
        type ReadVal = u32;
    }
    #[derive(Clone, Copy)]
    pub struct KvRdKeyCtrl();
    impl ureg::RegType for KvRdKeyCtrl {
        type Raw = u32;
    }
    impl ureg::ReadableReg for KvRdKeyCtrl {
        type ReadVal = crate::hmac::regs::KvRdReadVal;
    }
    impl ureg::WritableReg for KvRdKeyCtrl {
        type WriteVal = crate::hmac::regs::KvRdWriteVal;
    }
    impl ureg::ResettableReg for KvRdKeyCtrl {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct KvRdBlockCtrl();
    impl ureg::RegType for KvRdBlockCtrl {
        type Raw = u32;
    }
    impl ureg::ReadableReg for KvRdBlockCtrl {
        type ReadVal = crate::hmac::regs::KvRdReadVal;
    }
    impl ureg::WritableReg for KvRdBlockCtrl {
        type WriteVal = crate::hmac::regs::KvRdWriteVal;
    }
    impl ureg::ResettableReg for KvRdBlockCtrl {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct KvWrCtrl();
    impl ureg::RegType for KvWrCtrl {
        type Raw = u32;
    }
    impl ureg::ReadableReg for KvWrCtrl {
        type ReadVal = crate::hmac::regs::KvWrCtrlReadVal;
    }
    impl ureg::WritableReg for KvWrCtrl {
        type WriteVal = crate::hmac::regs::KvWrCtrlWriteVal;
    }
    impl ureg::ResettableReg for KvWrCtrl {
        const RESET_VAL: Self::Raw = 0;
    }
}
