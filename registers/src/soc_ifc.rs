// Licensed under the Apache-2.0 license.
//
// generated by caliptra_registers_generator with rtl-caliptra repo at 0c9dc1a67e12e35892210271401299d44b9b37a9
//
//
// Warning: rtl-caliptra was dirty: M src/keyvault/rtl/kv_def.rdl
//
#![allow(clippy::erasing_op)]
#![allow(clippy::identity_op)]
#[derive(Clone, Copy)]
pub struct RegisterBlock(*mut u32);
impl RegisterBlock {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    pub unsafe fn new(ptr: *mut u32) -> Self {
        Self(ptr)
    }
    pub fn soc_ifc_reg() -> Self {
        unsafe { Self::new(0x30030000 as *mut u32) }
    }
    /// Indicates fatal hardware error.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_hw_error_fatal(&self) -> ureg::RegRef<crate::soc_ifc::meta::CptraHwErrorFatal> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0 / core::mem::size_of::<u32>())) }
    }
    /// Indicates non-fatal hardware error.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_hw_error_non_fatal(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraHwErrorNonFatal> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(4 / core::mem::size_of::<u32>())) }
    }
    /// Indicates fatal firmware error.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_fw_error_fatal(&self) -> ureg::RegRef<crate::soc_ifc::meta::CptraFwErrorFatal> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(8 / core::mem::size_of::<u32>())) }
    }
    /// Indicates non-fatal firmware error.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_fw_error_non_fatal(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraFwErrorNonFatal> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0xc / core::mem::size_of::<u32>())) }
    }
    /// Encoded error value for hardware errors.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    /// [br]TAP Access [in debug/manuf mode]: RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_hw_error_enc(&self) -> ureg::RegRef<crate::soc_ifc::meta::CptraHwErrorEnc> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x10 / core::mem::size_of::<u32>())) }
    }
    /// Encoded error value for firmware errors.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    /// [br]TAP Access [in debug/manuf mode]: RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_fw_error_enc(&self) -> ureg::RegRef<crate::soc_ifc::meta::CptraFwErrorEnc> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x14 / core::mem::size_of::<u32>())) }
    }
    /// Firmware Extended Error information for firmware errors.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_fw_extended_error_info(
        &self,
    ) -> ureg::Array<8, ureg::RegRef<crate::soc_ifc::meta::CptraFwExtendedErrorInfo>> {
        unsafe { ureg::Array::new(self.0.wrapping_add(0x18 / core::mem::size_of::<u32>())) }
    }
    /// Reports the boot status.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    /// [br]TAP Access [in debug/manuf mode]: RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_boot_status(&self) -> ureg::RegRef<crate::soc_ifc::meta::CptraBootStatus> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x38 / core::mem::size_of::<u32>())) }
    }
    /// Reports the status of the firmware flows.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::CptraFlowStatusReadVal`]; Write value: [`soc_ifc::regs::CptraFlowStatusWriteVal`]
    pub fn cptra_flow_status(&self) -> ureg::RegRef<crate::soc_ifc::meta::CptraFlowStatus> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x3c / core::mem::size_of::<u32>())) }
    }
    /// Indicates to ROM the originating cause for the PC to be reset to 0.
    /// Only reset during cold-boot (sticky).
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::CptraResetReasonReadVal`]; Write value: [`soc_ifc::regs::CptraResetReasonWriteVal`]
    pub fn cptra_reset_reason(&self) -> ureg::RegRef<crate::soc_ifc::meta::CptraResetReason> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x40 / core::mem::size_of::<u32>())) }
    }
    /// Indicates current hardware security state.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::CptraSecurityStateReadVal`]; Write value: [`soc_ifc::regs::CptraSecurityStateWriteVal`]
    pub fn cptra_security_state(&self) -> ureg::RegRef<crate::soc_ifc::meta::CptraSecurityState> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x44 / core::mem::size_of::<u32>())) }
    }
    /// Valid PAUSER attributes for requests from SoC APB Interface.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    /// Read-Only once locked by PAUSER_LOCK.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_valid_pauser(
        &self,
    ) -> ureg::Array<5, ureg::RegRef<crate::soc_ifc::meta::CptraValidPauser>> {
        unsafe { ureg::Array::new(self.0.wrapping_add(0x48 / core::mem::size_of::<u32>())) }
    }
    /// Valid PAUSER attributes for requests from SoC APB Interface.
    /// Each bit corresponds to locking the associated  VALID_PAUSER register.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    /// Read-Only once locked.
    ///
    /// Read value: [`soc_ifc::regs::PauserLockReadVal`]; Write value: [`soc_ifc::regs::PauserLockWriteVal`]
    pub fn cptra_pauser_lock(
        &self,
    ) -> ureg::Array<5, ureg::RegRef<crate::soc_ifc::meta::CptraPauserLock>> {
        unsafe { ureg::Array::new(self.0.wrapping_add(0x5c / core::mem::size_of::<u32>())) }
    }
    /// Valid PAUSER attributes for TRNG on SoC APB Interface.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    /// Read-Only once locked by TRNG_PAUSER_LOCK.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_trng_valid_pauser(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraTrngValidPauser> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x70 / core::mem::size_of::<u32>())) }
    }
    /// Valid PAUSER attributes for requests from SoC APB Interface.
    /// Each bit corresponds to locking the associated VALID_PAUSER register.
    /// Caliptra FW RW access for survivability but cannot unlock once locked
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    /// Read-Only once locked.
    ///
    /// Read value: [`soc_ifc::regs::PauserLockReadVal`]; Write value: [`soc_ifc::regs::PauserLockWriteVal`]
    pub fn cptra_trng_pauser_lock(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraTrngPauserLock> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x74 / core::mem::size_of::<u32>())) }
    }
    /// Storage for the requested TRNG Data.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RW
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_trng_data(
        &self,
    ) -> ureg::Array<12, ureg::RegRef<crate::soc_ifc::meta::CptraTrngData>> {
        unsafe { ureg::Array::new(self.0.wrapping_add(0x78 / core::mem::size_of::<u32>())) }
    }
    /// TRNG Status register to indicate request and done
    ///
    /// Read value: [`soc_ifc::regs::CptraTrngStatusReadVal`]; Write value: [`soc_ifc::regs::CptraTrngStatusWriteVal`]
    pub fn cptra_trng_status(&self) -> ureg::RegRef<crate::soc_ifc::meta::CptraTrngStatus> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0xa8 / core::mem::size_of::<u32>())) }
    }
    /// Writes to fuse registers are completed. After the done bit is set, any subsequent writes to a fuse register will be dropped unless there is a power cycle or a warm reset or caliptra FW allows a write (negotiated through a mailbox command).
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RW1-S
    ///
    /// Read value: [`soc_ifc::regs::CptraFuseWrDoneReadVal`]; Write value: [`soc_ifc::regs::CptraFuseWrDoneWriteVal`]
    pub fn cptra_fuse_wr_done(&self) -> ureg::RegRef<crate::soc_ifc::meta::CptraFuseWrDone> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0xac / core::mem::size_of::<u32>())) }
    }
    /// Provides the clock period of the system clock.
    /// Used to standardize the RISC-V Standard MTIME count register.
    /// Clock Period is indicated as an integer number of picoseconds.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_timer_config(&self) -> ureg::RegRef<crate::soc_ifc::meta::CptraTimerConfig> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0xb0 / core::mem::size_of::<u32>())) }
    }
    /// Indicates that the BootFSM can continue to execute to bring the uController out of reset
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RW
    /// [br]TAP Access [in debug/manuf mode]: RW
    ///
    /// Read value: [`soc_ifc::regs::CptraBootfsmGoReadVal`]; Write value: [`soc_ifc::regs::CptraBootfsmGoWriteVal`]
    pub fn cptra_bootfsm_go(&self) -> ureg::RegRef<crate::soc_ifc::meta::CptraBootfsmGo> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0xb4 / core::mem::size_of::<u32>())) }
    }
    /// JTAG in debug/manuf mode or SOC can write to this register for ROM/FW defined skips or services; ROM/FW maintains the defintion of these bits.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RW
    /// [br]TAP Access [in debug/manuf mode]: RW
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_dbg_manuf_service_reg(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::CptraDbgManufServiceReg> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0xb8 / core::mem::size_of::<u32>())) }
    }
    /// Control register to enable or disable all of the caliptra clk gating. Default is 0 (disabled).
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RW
    ///
    /// Read value: [`soc_ifc::regs::CptraClkGatingEnReadVal`]; Write value: [`soc_ifc::regs::CptraClkGatingEnWriteVal`]
    pub fn cptra_clk_gating_en(&self) -> ureg::RegRef<crate::soc_ifc::meta::CptraClkGatingEn> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0xbc / core::mem::size_of::<u32>())) }
    }
    /// Generic input wires connected to SoC interface.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_generic_input_wires(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::soc_ifc::meta::CptraGenericInputWires>> {
        unsafe { ureg::Array::new(self.0.wrapping_add(0xc0 / core::mem::size_of::<u32>())) }
    }
    /// Generic output wires connected to SoC interface.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn cptra_generic_output_wires(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::soc_ifc::meta::CptraGenericOutputWires>> {
        unsafe { ureg::Array::new(self.0.wrapping_add(0xc8 / core::mem::size_of::<u32>())) }
    }
    /// Obfuscated UDS.
    /// [br]Caliptra Access: -
    /// [br]SOC Access:      WL-S
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn fuse_uds_seed(
        &self,
    ) -> ureg::Array<12, ureg::RegRef<crate::soc_ifc::meta::FuseUdsSeed>> {
        unsafe { ureg::Array::new(self.0.wrapping_add(0x200 / core::mem::size_of::<u32>())) }
    }
    /// Obfuscated Field Entropy.
    /// [br]Caliptra Access: -
    /// [br]SOC Access:      WL-S
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn fuse_field_entropy(
        &self,
    ) -> ureg::Array<8, ureg::RegRef<crate::soc_ifc::meta::FuseFieldEntropy>> {
        unsafe { ureg::Array::new(self.0.wrapping_add(0x230 / core::mem::size_of::<u32>())) }
    }
    /// Key Manifest PK hash Fuse.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn fuse_key_manifest_pk_hash(
        &self,
    ) -> ureg::Array<12, ureg::RegRef<crate::soc_ifc::meta::FuseKeyManifestPkHash>> {
        unsafe { ureg::Array::new(self.0.wrapping_add(0x250 / core::mem::size_of::<u32>())) }
    }
    /// Key Manifest Mask Fuse.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`soc_ifc::regs::FuseKeyManifestPkHashMaskReadVal`]; Write value: [`soc_ifc::regs::FuseKeyManifestPkHashMaskWriteVal`]
    pub fn fuse_key_manifest_pk_hash_mask(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::FuseKeyManifestPkHashMask> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x280 / core::mem::size_of::<u32>())) }
    }
    /// Owner PK hash Fuse.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn fuse_owner_pk_hash(
        &self,
    ) -> ureg::Array<12, ureg::RegRef<crate::soc_ifc::meta::FuseOwnerPkHash>> {
        unsafe { ureg::Array::new(self.0.wrapping_add(0x284 / core::mem::size_of::<u32>())) }
    }
    /// FMC Security Version Number.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn fuse_fmc_key_manifest_svn(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::FuseFmcKeyManifestSvn> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x2b4 / core::mem::size_of::<u32>())) }
    }
    /// Runtime SVN Fuse.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn fuse_runtime_svn(
        &self,
    ) -> ureg::Array<4, ureg::RegRef<crate::soc_ifc::meta::FuseRuntimeSvn>> {
        unsafe { ureg::Array::new(self.0.wrapping_add(0x2b8 / core::mem::size_of::<u32>())) }
    }
    /// Anti Rollback Disable Fuse.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`soc_ifc::regs::FuseAntiRollbackDisableReadVal`]; Write value: [`soc_ifc::regs::FuseAntiRollbackDisableWriteVal`]
    pub fn fuse_anti_rollback_disable(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::FuseAntiRollbackDisable> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x2c8 / core::mem::size_of::<u32>())) }
    }
    /// Manufacturer IEEE IDevID Certificate Gen Attributes.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn fuse_idevid_cert_attr(
        &self,
    ) -> ureg::Array<24, ureg::RegRef<crate::soc_ifc::meta::FuseIdevidCertAttr>> {
        unsafe { ureg::Array::new(self.0.wrapping_add(0x2cc / core::mem::size_of::<u32>())) }
    }
    /// Manufacturer IDEVID Manufacturer’s HSM identifier (this is used to find the certificate chain from the boot media)
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn fuse_idevid_manuf_hsm_id(
        &self,
    ) -> ureg::Array<4, ureg::RegRef<crate::soc_ifc::meta::FuseIdevidManufHsmId>> {
        unsafe { ureg::Array::new(self.0.wrapping_add(0x32c / core::mem::size_of::<u32>())) }
    }
    /// Caliptra Boot Media Integrated mode usage only. SOCs that build with a Boot Media Independent profile don’t have to account for these fuses.
    /// [br]Caliptra Access: RO
    /// [br]SOC Access:      RWL-S
    ///
    /// Read value: [`soc_ifc::regs::FuseLifeCycleReadVal`]; Write value: [`soc_ifc::regs::FuseLifeCycleWriteVal`]
    pub fn fuse_life_cycle(&self) -> ureg::RegRef<crate::soc_ifc::meta::FuseLifeCycle> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x33c / core::mem::size_of::<u32>())) }
    }
    /// Stored De-Obfuscation key, not accessible by software.
    /// [br]Caliptra Access: -
    /// [br]SOC Access:      -
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn internal_obf_key(
        &self,
    ) -> ureg::Array<8, ureg::RegRef<crate::soc_ifc::meta::InternalObfKey>> {
        unsafe { ureg::Array::new(self.0.wrapping_add(0x600 / core::mem::size_of::<u32>())) }
    }
    /// Lock feature gates writes to the ICCM. When lock is set to
    /// 1, writes are blocked. When cleared to 0, writes allowed.
    /// Write-once, meaning only a reset can clear it once set to 1.
    /// [br]Caliptra Access: RW1
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::InternalIccmLockReadVal`]; Write value: [`soc_ifc::regs::InternalIccmLockWriteVal`]
    pub fn internal_iccm_lock(&self) -> ureg::RegRef<crate::soc_ifc::meta::InternalIccmLock> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x620 / core::mem::size_of::<u32>())) }
    }
    /// Control register to assert FW update reset. When cleared to
    /// 0, no reset is triggered. When set to 1, uc-only reset is asserted.
    /// Field automatically clears 1 cycle after being set.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::InternalFwUpdateResetReadVal`]; Write value: [`soc_ifc::regs::InternalFwUpdateResetWriteVal`]
    pub fn internal_fw_update_reset(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::InternalFwUpdateReset> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x624 / core::mem::size_of::<u32>())) }
    }
    /// Control register to set the number of cycles for which FW update reset must be asserted. Default is 5. Max value is 255 (8 bit).
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`soc_ifc::regs::InternalFwUpdateResetWaitCyclesReadVal`]; Write value: [`soc_ifc::regs::InternalFwUpdateResetWaitCyclesWriteVal`]
    pub fn internal_fw_update_reset_wait_cycles(
        &self,
    ) -> ureg::RegRef<crate::soc_ifc::meta::InternalFwUpdateResetWaitCycles> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x628 / core::mem::size_of::<u32>())) }
    }
    /// 32-bit register providing the jump vector for RISC-V to transition for NMI handling code.
    /// Default is the base address of ROM, but may be updated for enhanced handling by runtime images.
    /// Bit [0] is ignored to enforce half-word alignment of address.
    /// [br]Caliptra Access: RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn internal_nmi_vector(&self) -> ureg::RegRef<crate::soc_ifc::meta::InternalNmiVector> {
        unsafe { ureg::RegRef::new(self.0.wrapping_add(0x62c / core::mem::size_of::<u32>())) }
    }
}
pub mod regs {
    //! Types that represent the values held by registers.
    #[derive(Clone, Copy)]
    pub struct CptraBootfsmGoReadVal(u32);
    impl CptraBootfsmGoReadVal {
        ///
        #[inline(always)]
        pub fn go(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> CptraBootfsmGoWriteVal {
            CptraBootfsmGoWriteVal(self.0)
        }
    }
    impl From<u32> for CptraBootfsmGoReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraBootfsmGoReadVal> for u32 {
        fn from(val: CptraBootfsmGoReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraBootfsmGoWriteVal(u32);
    impl CptraBootfsmGoWriteVal {
        ///
        #[inline(always)]
        pub fn go(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for CptraBootfsmGoWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraBootfsmGoWriteVal> for u32 {
        fn from(val: CptraBootfsmGoWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraClkGatingEnReadVal(u32);
    impl CptraClkGatingEnReadVal {
        /// Clk gating enable
        #[inline(always)]
        pub fn clk_gating_en(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> CptraClkGatingEnWriteVal {
            CptraClkGatingEnWriteVal(self.0)
        }
    }
    impl From<u32> for CptraClkGatingEnReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraClkGatingEnReadVal> for u32 {
        fn from(val: CptraClkGatingEnReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraClkGatingEnWriteVal(u32);
    impl CptraClkGatingEnWriteVal {
        /// Clk gating enable
        #[inline(always)]
        pub fn clk_gating_en(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for CptraClkGatingEnWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraClkGatingEnWriteVal> for u32 {
        fn from(val: CptraClkGatingEnWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraFlowStatusReadVal(u32);
    impl CptraFlowStatusReadVal {
        ///
        #[inline(always)]
        pub fn status(&self) -> u32 {
            (self.0 >> 0) & 0xfffffff
        }
        /// Indicates Caliptra is ready for Firmware Download
        #[inline(always)]
        pub fn ready_for_fw(&self) -> bool {
            ((self.0 >> 28) & 1) != 0
        }
        /// Indicates Caliptra is ready for Runtime Firmware Download
        #[inline(always)]
        pub fn ready_for_runtime(&self) -> bool {
            ((self.0 >> 29) & 1) != 0
        }
        /// Indicates Caliptra is ready for Fuses to be programmed.
        /// Read-only to both Caliptra and SOC.
        #[inline(always)]
        pub fn ready_for_fuses(&self) -> bool {
            ((self.0 >> 30) & 1) != 0
        }
        /// Indicates Caliptra is has completed Mailbox Flow.
        #[inline(always)]
        pub fn mailbox_flow_done(&self) -> bool {
            ((self.0 >> 31) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> CptraFlowStatusWriteVal {
            CptraFlowStatusWriteVal(self.0)
        }
    }
    impl From<u32> for CptraFlowStatusReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraFlowStatusReadVal> for u32 {
        fn from(val: CptraFlowStatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraFlowStatusWriteVal(u32);
    impl CptraFlowStatusWriteVal {
        ///
        #[inline(always)]
        pub fn status(self, val: u32) -> Self {
            Self((self.0 & !(0xfffffff << 0)) | ((val & 0xfffffff) << 0))
        }
        /// Indicates Caliptra is ready for Firmware Download
        #[inline(always)]
        pub fn ready_for_fw(self, val: bool) -> Self {
            Self((self.0 & !(1 << 28)) | (u32::from(val) << 28))
        }
        /// Indicates Caliptra is ready for Runtime Firmware Download
        #[inline(always)]
        pub fn ready_for_runtime(self, val: bool) -> Self {
            Self((self.0 & !(1 << 29)) | (u32::from(val) << 29))
        }
        /// Indicates Caliptra is has completed Mailbox Flow.
        #[inline(always)]
        pub fn mailbox_flow_done(self, val: bool) -> Self {
            Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
        }
    }
    impl From<u32> for CptraFlowStatusWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraFlowStatusWriteVal> for u32 {
        fn from(val: CptraFlowStatusWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraFuseWrDoneReadVal(u32);
    impl CptraFuseWrDoneReadVal {
        ///
        #[inline(always)]
        pub fn done(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> CptraFuseWrDoneWriteVal {
            CptraFuseWrDoneWriteVal(self.0)
        }
    }
    impl From<u32> for CptraFuseWrDoneReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraFuseWrDoneReadVal> for u32 {
        fn from(val: CptraFuseWrDoneReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraFuseWrDoneWriteVal(u32);
    impl CptraFuseWrDoneWriteVal {
        ///
        #[inline(always)]
        pub fn done(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for CptraFuseWrDoneWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraFuseWrDoneWriteVal> for u32 {
        fn from(val: CptraFuseWrDoneWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraResetReasonReadVal(u32);
    impl CptraResetReasonReadVal {
        /// FW update reset has been executed
        #[inline(always)]
        pub fn fw_upd_reset(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// warm reset has been executed
        #[inline(always)]
        pub fn warm_reset(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
    }
    impl From<u32> for CptraResetReasonReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraResetReasonReadVal> for u32 {
        fn from(val: CptraResetReasonReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraSecurityStateReadVal(u32);
    impl CptraSecurityStateReadVal {
        /// Device Lifecycle
        #[inline(always)]
        pub fn device_lifecycle(&self) -> super::enums::DeviceLifecycleE {
            super::enums::DeviceLifecycleE::try_from((self.0 >> 0) & 3).unwrap()
        }
        /// Debug Locked
        #[inline(always)]
        pub fn debug_locked(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        /// Reserved field
        #[inline(always)]
        pub fn rsvd(&self) -> u32 {
            (self.0 >> 3) & 0x1fffffff
        }
    }
    impl From<u32> for CptraSecurityStateReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraSecurityStateReadVal> for u32 {
        fn from(val: CptraSecurityStateReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraTrngStatusReadVal(u32);
    impl CptraTrngStatusReadVal {
        /// Indicates that the requests TRNG Data is done and stored in the TRNG Data register.
        /// [br]Caliptra Access: RW
        /// [br]SOC Access:      RO
        #[inline(always)]
        pub fn data_req(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Indicates that the requests TRNG Data is done and stored in the TRNG Data register.
        /// [br]Caliptra Access: RO
        /// [br]SOC Access:      RW
        #[inline(always)]
        pub fn data_wr_done(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> CptraTrngStatusWriteVal {
            CptraTrngStatusWriteVal(self.0)
        }
    }
    impl From<u32> for CptraTrngStatusReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraTrngStatusReadVal> for u32 {
        fn from(val: CptraTrngStatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CptraTrngStatusWriteVal(u32);
    impl CptraTrngStatusWriteVal {
        /// Indicates that the requests TRNG Data is done and stored in the TRNG Data register.
        /// [br]Caliptra Access: RW
        /// [br]SOC Access:      RO
        #[inline(always)]
        pub fn data_req(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        /// Indicates that the requests TRNG Data is done and stored in the TRNG Data register.
        /// [br]Caliptra Access: RO
        /// [br]SOC Access:      RW
        #[inline(always)]
        pub fn data_wr_done(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
    }
    impl From<u32> for CptraTrngStatusWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraTrngStatusWriteVal> for u32 {
        fn from(val: CptraTrngStatusWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct PauserLockReadVal(u32);
    impl PauserLockReadVal {
        ///
        #[inline(always)]
        pub fn lock(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> PauserLockWriteVal {
            PauserLockWriteVal(self.0)
        }
    }
    impl From<u32> for PauserLockReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<PauserLockReadVal> for u32 {
        fn from(val: PauserLockReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct PauserLockWriteVal(u32);
    impl PauserLockWriteVal {
        ///
        #[inline(always)]
        pub fn lock(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for PauserLockWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<PauserLockWriteVal> for u32 {
        fn from(val: PauserLockWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FuseAntiRollbackDisableReadVal(u32);
    impl FuseAntiRollbackDisableReadVal {
        ///
        #[inline(always)]
        pub fn dis(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> FuseAntiRollbackDisableWriteVal {
            FuseAntiRollbackDisableWriteVal(self.0)
        }
    }
    impl From<u32> for FuseAntiRollbackDisableReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FuseAntiRollbackDisableReadVal> for u32 {
        fn from(val: FuseAntiRollbackDisableReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FuseAntiRollbackDisableWriteVal(u32);
    impl FuseAntiRollbackDisableWriteVal {
        ///
        #[inline(always)]
        pub fn dis(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for FuseAntiRollbackDisableWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FuseAntiRollbackDisableWriteVal> for u32 {
        fn from(val: FuseAntiRollbackDisableWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FuseKeyManifestPkHashMaskReadVal(u32);
    impl FuseKeyManifestPkHashMaskReadVal {
        ///
        #[inline(always)]
        pub fn mask(&self) -> u32 {
            (self.0 >> 0) & 0xf
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> FuseKeyManifestPkHashMaskWriteVal {
            FuseKeyManifestPkHashMaskWriteVal(self.0)
        }
    }
    impl From<u32> for FuseKeyManifestPkHashMaskReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FuseKeyManifestPkHashMaskReadVal> for u32 {
        fn from(val: FuseKeyManifestPkHashMaskReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FuseKeyManifestPkHashMaskWriteVal(u32);
    impl FuseKeyManifestPkHashMaskWriteVal {
        ///
        #[inline(always)]
        pub fn mask(self, val: u32) -> Self {
            Self((self.0 & !(0xf << 0)) | ((val & 0xf) << 0))
        }
    }
    impl From<u32> for FuseKeyManifestPkHashMaskWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FuseKeyManifestPkHashMaskWriteVal> for u32 {
        fn from(val: FuseKeyManifestPkHashMaskWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FuseLifeCycleReadVal(u32);
    impl FuseLifeCycleReadVal {
        ///
        #[inline(always)]
        pub fn life_cycle(&self) -> u32 {
            (self.0 >> 0) & 3
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> FuseLifeCycleWriteVal {
            FuseLifeCycleWriteVal(self.0)
        }
    }
    impl From<u32> for FuseLifeCycleReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FuseLifeCycleReadVal> for u32 {
        fn from(val: FuseLifeCycleReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct FuseLifeCycleWriteVal(u32);
    impl FuseLifeCycleWriteVal {
        ///
        #[inline(always)]
        pub fn life_cycle(self, val: u32) -> Self {
            Self((self.0 & !(3 << 0)) | ((val & 3) << 0))
        }
    }
    impl From<u32> for FuseLifeCycleWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FuseLifeCycleWriteVal> for u32 {
        fn from(val: FuseLifeCycleWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalFwUpdateResetReadVal(u32);
    impl InternalFwUpdateResetReadVal {
        /// FW Update reset to reset core
        #[inline(always)]
        pub fn core_rst(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> InternalFwUpdateResetWriteVal {
            InternalFwUpdateResetWriteVal(self.0)
        }
    }
    impl From<u32> for InternalFwUpdateResetReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalFwUpdateResetReadVal> for u32 {
        fn from(val: InternalFwUpdateResetReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalFwUpdateResetWriteVal(u32);
    impl InternalFwUpdateResetWriteVal {
        /// FW Update reset to reset core
        #[inline(always)]
        pub fn core_rst(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for InternalFwUpdateResetWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalFwUpdateResetWriteVal> for u32 {
        fn from(val: InternalFwUpdateResetWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalFwUpdateResetWaitCyclesReadVal(u32);
    impl InternalFwUpdateResetWaitCyclesReadVal {
        /// FW Update reset wait cycles
        #[inline(always)]
        pub fn wait_cycles(&self) -> u32 {
            (self.0 >> 0) & 0xff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> InternalFwUpdateResetWaitCyclesWriteVal {
            InternalFwUpdateResetWaitCyclesWriteVal(self.0)
        }
    }
    impl From<u32> for InternalFwUpdateResetWaitCyclesReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalFwUpdateResetWaitCyclesReadVal> for u32 {
        fn from(val: InternalFwUpdateResetWaitCyclesReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalFwUpdateResetWaitCyclesWriteVal(u32);
    impl InternalFwUpdateResetWaitCyclesWriteVal {
        /// FW Update reset wait cycles
        #[inline(always)]
        pub fn wait_cycles(self, val: u32) -> Self {
            Self((self.0 & !(0xff << 0)) | ((val & 0xff) << 0))
        }
    }
    impl From<u32> for InternalFwUpdateResetWaitCyclesWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalFwUpdateResetWaitCyclesWriteVal> for u32 {
        fn from(val: InternalFwUpdateResetWaitCyclesWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalIccmLockReadVal(u32);
    impl InternalIccmLockReadVal {
        /// Lock bit gates writes to ICCM. Write 1 to set - cannot be cleared by SW.
        #[inline(always)]
        pub fn lock(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> InternalIccmLockWriteVal {
            InternalIccmLockWriteVal(self.0)
        }
    }
    impl From<u32> for InternalIccmLockReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalIccmLockReadVal> for u32 {
        fn from(val: InternalIccmLockReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct InternalIccmLockWriteVal(u32);
    impl InternalIccmLockWriteVal {
        /// Lock bit gates writes to ICCM. Write 1 to set - cannot be cleared by SW.
        #[inline(always)]
        pub fn lock(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
    }
    impl From<u32> for InternalIccmLockWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<InternalIccmLockWriteVal> for u32 {
        fn from(val: InternalIccmLockWriteVal) -> u32 {
            val.0
        }
    }
}
pub mod enums {
    //! Enumerations used by some register fields.
    #[derive(Clone, Copy, Eq, PartialEq)]
    #[repr(u32)]
    pub enum DeviceLifecycleE {
        DeviceUnprovisioned = 0,
        DeviceManufacturing = 1,
        Reserved2 = 2,
        DeviceProduction = 3,
    }
    impl DeviceLifecycleE {
        #[inline(always)]
        pub fn device_unprovisioned(&self) -> bool {
            *self == Self::DeviceUnprovisioned
        }
        #[inline(always)]
        pub fn device_manufacturing(&self) -> bool {
            *self == Self::DeviceManufacturing
        }
        #[inline(always)]
        pub fn device_production(&self) -> bool {
            *self == Self::DeviceProduction
        }
    }
    impl TryFrom<u32> for DeviceLifecycleE {
        type Error = ();
        #[inline(always)]
        fn try_from(val: u32) -> Result<DeviceLifecycleE, ()> {
            match val {
                0 => Ok(Self::DeviceUnprovisioned),
                1 => Ok(Self::DeviceManufacturing),
                2 => Ok(Self::Reserved2),
                3 => Ok(Self::DeviceProduction),
                _ => Err(()),
            }
        }
    }
    impl From<DeviceLifecycleE> for u32 {
        fn from(val: DeviceLifecycleE) -> Self {
            val as u32
        }
    }
    pub mod selector {
        pub struct DeviceLifecycleESelector();
        impl DeviceLifecycleESelector {
            #[inline(always)]
            pub fn device_unprovisioned(&self) -> super::DeviceLifecycleE {
                super::DeviceLifecycleE::DeviceUnprovisioned
            }
            #[inline(always)]
            pub fn device_manufacturing(&self) -> super::DeviceLifecycleE {
                super::DeviceLifecycleE::DeviceManufacturing
            }
            #[inline(always)]
            pub fn device_production(&self) -> super::DeviceLifecycleE {
                super::DeviceLifecycleE::DeviceProduction
            }
        }
    }
}
pub mod meta {
    //! Additional metadata needed by ureg.
    #[derive(Clone, Copy)]
    pub struct CptraHwErrorFatal();
    impl ureg::RegType for CptraHwErrorFatal {
        type Raw = u32;
    }
    impl ureg::ReadableReg for CptraHwErrorFatal {
        type ReadVal = u32;
    }
    impl ureg::WritableReg for CptraHwErrorFatal {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for CptraHwErrorFatal {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct CptraHwErrorNonFatal();
    impl ureg::RegType for CptraHwErrorNonFatal {
        type Raw = u32;
    }
    impl ureg::ReadableReg for CptraHwErrorNonFatal {
        type ReadVal = u32;
    }
    impl ureg::WritableReg for CptraHwErrorNonFatal {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for CptraHwErrorNonFatal {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct CptraFwErrorFatal();
    impl ureg::RegType for CptraFwErrorFatal {
        type Raw = u32;
    }
    impl ureg::ReadableReg for CptraFwErrorFatal {
        type ReadVal = u32;
    }
    impl ureg::WritableReg for CptraFwErrorFatal {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for CptraFwErrorFatal {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct CptraFwErrorNonFatal();
    impl ureg::RegType for CptraFwErrorNonFatal {
        type Raw = u32;
    }
    impl ureg::ReadableReg for CptraFwErrorNonFatal {
        type ReadVal = u32;
    }
    impl ureg::WritableReg for CptraFwErrorNonFatal {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for CptraFwErrorNonFatal {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct CptraHwErrorEnc();
    impl ureg::RegType for CptraHwErrorEnc {
        type Raw = u32;
    }
    impl ureg::ReadableReg for CptraHwErrorEnc {
        type ReadVal = u32;
    }
    impl ureg::WritableReg for CptraHwErrorEnc {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for CptraHwErrorEnc {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct CptraFwErrorEnc();
    impl ureg::RegType for CptraFwErrorEnc {
        type Raw = u32;
    }
    impl ureg::ReadableReg for CptraFwErrorEnc {
        type ReadVal = u32;
    }
    impl ureg::WritableReg for CptraFwErrorEnc {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for CptraFwErrorEnc {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct CptraFwExtendedErrorInfo();
    impl ureg::RegType for CptraFwExtendedErrorInfo {
        type Raw = u32;
    }
    impl ureg::ReadableReg for CptraFwExtendedErrorInfo {
        type ReadVal = u32;
    }
    impl ureg::WritableReg for CptraFwExtendedErrorInfo {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for CptraFwExtendedErrorInfo {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct CptraBootStatus();
    impl ureg::RegType for CptraBootStatus {
        type Raw = u32;
    }
    impl ureg::ReadableReg for CptraBootStatus {
        type ReadVal = u32;
    }
    impl ureg::WritableReg for CptraBootStatus {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for CptraBootStatus {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct CptraFlowStatus();
    impl ureg::RegType for CptraFlowStatus {
        type Raw = u32;
    }
    impl ureg::ReadableReg for CptraFlowStatus {
        type ReadVal = crate::soc_ifc::regs::CptraFlowStatusReadVal;
    }
    impl ureg::WritableReg for CptraFlowStatus {
        type WriteVal = crate::soc_ifc::regs::CptraFlowStatusWriteVal;
    }
    impl ureg::ResettableReg for CptraFlowStatus {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct CptraResetReason();
    impl ureg::RegType for CptraResetReason {
        type Raw = u32;
    }
    impl ureg::ReadableReg for CptraResetReason {
        type ReadVal = crate::soc_ifc::regs::CptraResetReasonReadVal;
    }
    #[derive(Clone, Copy)]
    pub struct CptraSecurityState();
    impl ureg::RegType for CptraSecurityState {
        type Raw = u32;
    }
    impl ureg::ReadableReg for CptraSecurityState {
        type ReadVal = crate::soc_ifc::regs::CptraSecurityStateReadVal;
    }
    #[derive(Clone, Copy)]
    pub struct CptraValidPauser();
    impl ureg::RegType for CptraValidPauser {
        type Raw = u32;
    }
    impl ureg::ReadableReg for CptraValidPauser {
        type ReadVal = u32;
    }
    impl ureg::WritableReg for CptraValidPauser {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for CptraValidPauser {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct CptraPauserLock();
    impl ureg::RegType for CptraPauserLock {
        type Raw = u32;
    }
    impl ureg::ReadableReg for CptraPauserLock {
        type ReadVal = crate::soc_ifc::regs::PauserLockReadVal;
    }
    impl ureg::WritableReg for CptraPauserLock {
        type WriteVal = crate::soc_ifc::regs::PauserLockWriteVal;
    }
    impl ureg::ResettableReg for CptraPauserLock {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct CptraTrngValidPauser();
    impl ureg::RegType for CptraTrngValidPauser {
        type Raw = u32;
    }
    impl ureg::ReadableReg for CptraTrngValidPauser {
        type ReadVal = u32;
    }
    impl ureg::WritableReg for CptraTrngValidPauser {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for CptraTrngValidPauser {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct CptraTrngPauserLock();
    impl ureg::RegType for CptraTrngPauserLock {
        type Raw = u32;
    }
    impl ureg::ReadableReg for CptraTrngPauserLock {
        type ReadVal = crate::soc_ifc::regs::PauserLockReadVal;
    }
    impl ureg::WritableReg for CptraTrngPauserLock {
        type WriteVal = crate::soc_ifc::regs::PauserLockWriteVal;
    }
    impl ureg::ResettableReg for CptraTrngPauserLock {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct CptraTrngData();
    impl ureg::RegType for CptraTrngData {
        type Raw = u32;
    }
    impl ureg::ReadableReg for CptraTrngData {
        type ReadVal = u32;
    }
    impl ureg::WritableReg for CptraTrngData {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for CptraTrngData {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct CptraTrngStatus();
    impl ureg::RegType for CptraTrngStatus {
        type Raw = u32;
    }
    impl ureg::ReadableReg for CptraTrngStatus {
        type ReadVal = crate::soc_ifc::regs::CptraTrngStatusReadVal;
    }
    impl ureg::WritableReg for CptraTrngStatus {
        type WriteVal = crate::soc_ifc::regs::CptraTrngStatusWriteVal;
    }
    impl ureg::ResettableReg for CptraTrngStatus {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct CptraFuseWrDone();
    impl ureg::RegType for CptraFuseWrDone {
        type Raw = u32;
    }
    impl ureg::ReadableReg for CptraFuseWrDone {
        type ReadVal = crate::soc_ifc::regs::CptraFuseWrDoneReadVal;
    }
    impl ureg::WritableReg for CptraFuseWrDone {
        type WriteVal = crate::soc_ifc::regs::CptraFuseWrDoneWriteVal;
    }
    impl ureg::ResettableReg for CptraFuseWrDone {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct CptraTimerConfig();
    impl ureg::RegType for CptraTimerConfig {
        type Raw = u32;
    }
    impl ureg::ReadableReg for CptraTimerConfig {
        type ReadVal = u32;
    }
    impl ureg::WritableReg for CptraTimerConfig {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for CptraTimerConfig {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct CptraBootfsmGo();
    impl ureg::RegType for CptraBootfsmGo {
        type Raw = u32;
    }
    impl ureg::ReadableReg for CptraBootfsmGo {
        type ReadVal = crate::soc_ifc::regs::CptraBootfsmGoReadVal;
    }
    impl ureg::WritableReg for CptraBootfsmGo {
        type WriteVal = crate::soc_ifc::regs::CptraBootfsmGoWriteVal;
    }
    impl ureg::ResettableReg for CptraBootfsmGo {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct CptraDbgManufServiceReg();
    impl ureg::RegType for CptraDbgManufServiceReg {
        type Raw = u32;
    }
    impl ureg::ReadableReg for CptraDbgManufServiceReg {
        type ReadVal = u32;
    }
    impl ureg::WritableReg for CptraDbgManufServiceReg {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for CptraDbgManufServiceReg {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct CptraClkGatingEn();
    impl ureg::RegType for CptraClkGatingEn {
        type Raw = u32;
    }
    impl ureg::ReadableReg for CptraClkGatingEn {
        type ReadVal = crate::soc_ifc::regs::CptraClkGatingEnReadVal;
    }
    impl ureg::WritableReg for CptraClkGatingEn {
        type WriteVal = crate::soc_ifc::regs::CptraClkGatingEnWriteVal;
    }
    impl ureg::ResettableReg for CptraClkGatingEn {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct CptraGenericInputWires();
    impl ureg::RegType for CptraGenericInputWires {
        type Raw = u32;
    }
    impl ureg::ReadableReg for CptraGenericInputWires {
        type ReadVal = u32;
    }
    #[derive(Clone, Copy)]
    pub struct CptraGenericOutputWires();
    impl ureg::RegType for CptraGenericOutputWires {
        type Raw = u32;
    }
    impl ureg::ReadableReg for CptraGenericOutputWires {
        type ReadVal = u32;
    }
    impl ureg::WritableReg for CptraGenericOutputWires {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for CptraGenericOutputWires {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct FuseUdsSeed();
    impl ureg::RegType for FuseUdsSeed {
        type Raw = u32;
    }
    impl ureg::WritableReg for FuseUdsSeed {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for FuseUdsSeed {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct FuseFieldEntropy();
    impl ureg::RegType for FuseFieldEntropy {
        type Raw = u32;
    }
    impl ureg::WritableReg for FuseFieldEntropy {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for FuseFieldEntropy {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct FuseKeyManifestPkHash();
    impl ureg::RegType for FuseKeyManifestPkHash {
        type Raw = u32;
    }
    impl ureg::ReadableReg for FuseKeyManifestPkHash {
        type ReadVal = u32;
    }
    impl ureg::WritableReg for FuseKeyManifestPkHash {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for FuseKeyManifestPkHash {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct FuseKeyManifestPkHashMask();
    impl ureg::RegType for FuseKeyManifestPkHashMask {
        type Raw = u32;
    }
    impl ureg::ReadableReg for FuseKeyManifestPkHashMask {
        type ReadVal = crate::soc_ifc::regs::FuseKeyManifestPkHashMaskReadVal;
    }
    impl ureg::WritableReg for FuseKeyManifestPkHashMask {
        type WriteVal = crate::soc_ifc::regs::FuseKeyManifestPkHashMaskWriteVal;
    }
    impl ureg::ResettableReg for FuseKeyManifestPkHashMask {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct FuseOwnerPkHash();
    impl ureg::RegType for FuseOwnerPkHash {
        type Raw = u32;
    }
    impl ureg::ReadableReg for FuseOwnerPkHash {
        type ReadVal = u32;
    }
    impl ureg::WritableReg for FuseOwnerPkHash {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for FuseOwnerPkHash {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct FuseFmcKeyManifestSvn();
    impl ureg::RegType for FuseFmcKeyManifestSvn {
        type Raw = u32;
    }
    impl ureg::ReadableReg for FuseFmcKeyManifestSvn {
        type ReadVal = u32;
    }
    impl ureg::WritableReg for FuseFmcKeyManifestSvn {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for FuseFmcKeyManifestSvn {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct FuseRuntimeSvn();
    impl ureg::RegType for FuseRuntimeSvn {
        type Raw = u32;
    }
    impl ureg::ReadableReg for FuseRuntimeSvn {
        type ReadVal = u32;
    }
    impl ureg::WritableReg for FuseRuntimeSvn {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for FuseRuntimeSvn {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct FuseAntiRollbackDisable();
    impl ureg::RegType for FuseAntiRollbackDisable {
        type Raw = u32;
    }
    impl ureg::ReadableReg for FuseAntiRollbackDisable {
        type ReadVal = crate::soc_ifc::regs::FuseAntiRollbackDisableReadVal;
    }
    impl ureg::WritableReg for FuseAntiRollbackDisable {
        type WriteVal = crate::soc_ifc::regs::FuseAntiRollbackDisableWriteVal;
    }
    impl ureg::ResettableReg for FuseAntiRollbackDisable {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct FuseIdevidCertAttr();
    impl ureg::RegType for FuseIdevidCertAttr {
        type Raw = u32;
    }
    impl ureg::ReadableReg for FuseIdevidCertAttr {
        type ReadVal = u32;
    }
    impl ureg::WritableReg for FuseIdevidCertAttr {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for FuseIdevidCertAttr {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct FuseIdevidManufHsmId();
    impl ureg::RegType for FuseIdevidManufHsmId {
        type Raw = u32;
    }
    impl ureg::ReadableReg for FuseIdevidManufHsmId {
        type ReadVal = u32;
    }
    impl ureg::WritableReg for FuseIdevidManufHsmId {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for FuseIdevidManufHsmId {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct FuseLifeCycle();
    impl ureg::RegType for FuseLifeCycle {
        type Raw = u32;
    }
    impl ureg::ReadableReg for FuseLifeCycle {
        type ReadVal = crate::soc_ifc::regs::FuseLifeCycleReadVal;
    }
    impl ureg::WritableReg for FuseLifeCycle {
        type WriteVal = crate::soc_ifc::regs::FuseLifeCycleWriteVal;
    }
    impl ureg::ResettableReg for FuseLifeCycle {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct InternalObfKey();
    impl ureg::RegType for InternalObfKey {
        type Raw = u32;
    }
    impl ureg::WritableReg for InternalObfKey {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for InternalObfKey {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct InternalIccmLock();
    impl ureg::RegType for InternalIccmLock {
        type Raw = u32;
    }
    impl ureg::ReadableReg for InternalIccmLock {
        type ReadVal = crate::soc_ifc::regs::InternalIccmLockReadVal;
    }
    impl ureg::WritableReg for InternalIccmLock {
        type WriteVal = crate::soc_ifc::regs::InternalIccmLockWriteVal;
    }
    impl ureg::ResettableReg for InternalIccmLock {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct InternalFwUpdateReset();
    impl ureg::RegType for InternalFwUpdateReset {
        type Raw = u32;
    }
    impl ureg::ReadableReg for InternalFwUpdateReset {
        type ReadVal = crate::soc_ifc::regs::InternalFwUpdateResetReadVal;
    }
    impl ureg::WritableReg for InternalFwUpdateReset {
        type WriteVal = crate::soc_ifc::regs::InternalFwUpdateResetWriteVal;
    }
    impl ureg::ResettableReg for InternalFwUpdateReset {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct InternalFwUpdateResetWaitCycles();
    impl ureg::RegType for InternalFwUpdateResetWaitCycles {
        type Raw = u32;
    }
    impl ureg::ReadableReg for InternalFwUpdateResetWaitCycles {
        type ReadVal = crate::soc_ifc::regs::InternalFwUpdateResetWaitCyclesReadVal;
    }
    impl ureg::WritableReg for InternalFwUpdateResetWaitCycles {
        type WriteVal = crate::soc_ifc::regs::InternalFwUpdateResetWaitCyclesWriteVal;
    }
    impl ureg::ResettableReg for InternalFwUpdateResetWaitCycles {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct InternalNmiVector();
    impl ureg::RegType for InternalNmiVector {
        type Raw = u32;
    }
    impl ureg::ReadableReg for InternalNmiVector {
        type ReadVal = u32;
    }
    impl ureg::WritableReg for InternalNmiVector {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for InternalNmiVector {
        const RESET_VAL: Self::Raw = 0;
    }
}
