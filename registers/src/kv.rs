// Licensed under the Apache-2.0 license.
//
// generated by caliptra_registers_generator with rtl-caliptra repo at f1feedff601b55715ccaed60ebfcd83543617752
//
#![allow(clippy::erasing_op)]
#![allow(clippy::identity_op)]
#[derive(Clone, Copy)]
pub struct RegisterBlock(*mut u32);
impl RegisterBlock {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    pub unsafe fn new(ptr: *mut u32) -> Self {
        Self(ptr)
    }
    pub fn kv_reg() -> Self {
        unsafe { Self::new(0x10018000 as *mut u32) }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn pcr_entry(
        &self,
    ) -> ureg::Array<8, ureg::Array<16, ureg::RegRef<crate::kv::meta::PcrEntry>>> {
        unsafe { ureg::Array::new(self.0.wrapping_add(0 / core::mem::size_of::<u32>())) }
    }
    /// Read value: [`kv::regs::CtrlReadVal`]; Write value: [`kv::regs::CtrlWriteVal`]
    pub fn key_ctrl(&self) -> ureg::Array<8, ureg::RegRef<crate::kv::meta::KeyCtrl>> {
        unsafe { ureg::Array::new(self.0.wrapping_add(0x80 / core::mem::size_of::<u32>())) }
    }
    /// Read value: [`kv::regs::CtrlReadVal`]; Write value: [`kv::regs::CtrlWriteVal`]
    pub fn pcr_ctrl(&self) -> ureg::Array<8, ureg::RegRef<crate::kv::meta::PcrCtrl>> {
        unsafe { ureg::Array::new(self.0.wrapping_add(0x88 / core::mem::size_of::<u32>())) }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    pub fn key_entry(
        &self,
    ) -> ureg::Array<8, ureg::Array<16, ureg::RegRef<crate::kv::meta::KeyEntry>>> {
        unsafe { ureg::Array::new(self.0.wrapping_add(0x90 / core::mem::size_of::<u32>())) }
    }
}
pub mod regs {
    //! Types that represent the values held by registers.
    #[derive(Clone, Copy)]
    pub struct CtrlReadVal(u32);
    impl CtrlReadVal {
        ///
        #[inline(always)]
        pub fn lock_rd(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn lock_wr(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn lock_use(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn clear(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn dest_valid(&self) -> u32 {
            (self.0 >> 9) & 0x3f
        }
        ///
        #[inline(always)]
        pub fn rsvd(&self) -> u32 {
            (self.0 >> 15) & 0x1ffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        pub fn modify(self) -> CtrlWriteVal {
            CtrlWriteVal(self.0)
        }
    }
    impl From<u32> for CtrlReadVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CtrlReadVal> for u32 {
        fn from(val: CtrlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct CtrlWriteVal(u32);
    impl CtrlWriteVal {
        ///
        #[inline(always)]
        pub fn lock_rd(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u32::from(val) << 0))
        }
        ///
        #[inline(always)]
        pub fn lock_wr(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
        ///
        #[inline(always)]
        pub fn lock_use(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
        }
        ///
        #[inline(always)]
        pub fn clear(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
        }
        ///
        #[inline(always)]
        pub fn rsvd(self, val: u32) -> Self {
            Self((self.0 & !(0x1ffff << 15)) | ((val & 0x1ffff) << 15))
        }
    }
    impl From<u32> for CtrlWriteVal {
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CtrlWriteVal> for u32 {
        fn from(val: CtrlWriteVal) -> u32 {
            val.0
        }
    }
}
pub mod enums {
    //! Enumerations used by some register fields.
    pub mod selector {}
}
pub mod meta {
    //! Additional metadata needed by ureg.
    #[derive(Clone, Copy)]
    pub struct PcrEntry();
    impl ureg::RegType for PcrEntry {
        type Raw = u32;
    }
    impl ureg::ReadableReg for PcrEntry {
        type ReadVal = u32;
    }
    impl ureg::WritableReg for PcrEntry {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for PcrEntry {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct KeyCtrl();
    impl ureg::RegType for KeyCtrl {
        type Raw = u32;
    }
    impl ureg::ReadableReg for KeyCtrl {
        type ReadVal = crate::kv::regs::CtrlReadVal;
    }
    impl ureg::WritableReg for KeyCtrl {
        type WriteVal = crate::kv::regs::CtrlWriteVal;
    }
    impl ureg::ResettableReg for KeyCtrl {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct PcrCtrl();
    impl ureg::RegType for PcrCtrl {
        type Raw = u32;
    }
    impl ureg::ReadableReg for PcrCtrl {
        type ReadVal = crate::kv::regs::CtrlReadVal;
    }
    impl ureg::WritableReg for PcrCtrl {
        type WriteVal = crate::kv::regs::CtrlWriteVal;
    }
    impl ureg::ResettableReg for PcrCtrl {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct KeyEntry();
    impl ureg::RegType for KeyEntry {
        type Raw = u32;
    }
    impl ureg::WritableReg for KeyEntry {
        type WriteVal = u32;
    }
    impl ureg::ResettableReg for KeyEntry {
        const RESET_VAL: Self::Raw = 0;
    }
}
