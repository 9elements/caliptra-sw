// Licensed under the Apache-2.0 license.

use std::fmt::Write;
use std::rc::Rc;
use std::{error::Error, path::Path, process::Command};

use caliptra_systemrdl as systemrdl;
use quote::{format_ident, quote};
use ureg_schema::{Enum, EnumVariant, Register};

static HEADER_PREFIX: &str = r"/*
Licensed under the Apache-2.0 license.
";

static HEADER_SUFFIX: &str = r"
*/
";

static CALIPTRA_RDL_FILES: &[&str] = &[
    "src/libs/rtl/interrupt_regs.rdl",
    "src/keyvault/rtl/kv_def.rdl",
    "src/keyvault/rtl/kv_reg.rdl",
    "src/doe/rtl/doe_reg.rdl",
    "src/ecc/rtl/ecc_reg.rdl",
    "src/hmac/rtl/hmac_reg.rdl",
    "src/sha256/rtl/sha256_reg.rdl",
    "src/sha512/rtl/sha512_reg.rdl",
    "src/soc_ifc/rtl/mbox_csr.rdl",
    "src/soc_ifc/rtl/soc_ifc_reg.rdl",
    "src/integration/rtl/caliptra_reg.rdl",
];

fn run_cmd(cmd: &mut Command) -> Result<(), Box<dyn Error>> {
    let status = cmd.status()?;
    if status.success() {
        Ok(())
    } else {
        Err(format!(
            "Process {:?} {:?} exited with status code {:?}",
            cmd.get_program(),
            cmd.get_args(),
            status.code()
        )
        .into())
    }
}

fn run_cmd_stdout(cmd: &mut Command) -> Result<String, Box<dyn Error>> {
    let out = cmd.output()?;
    if out.status.success() {
        Ok(String::from_utf8_lossy(&out.stdout).into())
    } else {
        Err(format!(
            "Process {:?} {:?} exited with status code {:?} stderr {}",
            cmd.get_program(),
            cmd.get_args(),
            out.status.code(),
            String::from_utf8_lossy(&out.stderr)
        )
        .into())
    }
}

fn remove_reg_prefixes(registers: &mut [Rc<Register>], prefix: &str) {
    for reg in registers.iter_mut() {
        if reg.name.to_ascii_lowercase().starts_with(prefix) {
            let reg = Rc::make_mut(reg);
            reg.name = reg.name[prefix.len()..].to_string();
        }
    }
}

fn real_main() -> Result<(), Box<dyn Error>> {
    let args: Vec<String> = std::env::args().collect();
    if args.len() < 3 {
        Err("Usage: codegen <caliptra_rtl_dir> <dest_dir>")?;
    }

    let rtl_dir = Path::new(&args[1]);
    let rdl_files = CALIPTRA_RDL_FILES
        .iter()
        .map(|p| rtl_dir.join(p))
        .try_fold(
            vec![],
            |mut acc, name| -> std::io::Result<Vec<systemrdl::InputFile>> {
                acc.push(systemrdl::InputFile::read(&name)?);
                Ok(acc)
            },
        )?;

    let rtl_commit_id = run_cmd_stdout(
        Command::new("git")
            .current_dir(rtl_dir)
            .arg("rev-parse")
            .arg("HEAD"),
    )?;
    let rtl_git_status = run_cmd_stdout(
        Command::new("git")
            .current_dir(rtl_dir)
            .arg("status")
            .arg("--porcelain"),
    )?;
    let mut header = HEADER_PREFIX.to_string();
    write!(
        &mut header,
        "\n generated by caliptra_registers_generator with rtl-caliptra repo at {rtl_commit_id}"
    )?;
    if !rtl_git_status.is_empty() {
        write!(
            &mut header,
            "\n\nWarning: rtl-caliptra was dirty:{rtl_git_status}"
        )?;
    }
    header.push_str(HEADER_SUFFIX);

    let dest_dir = Path::new(&args[args.len() - 1]);

    let scope = caliptra_systemrdl::Scope::parse_root(&rdl_files).map_err(|s| s.to_string())?;
    let scope = scope.as_parent();

    let addrmap = scope.lookup_typedef("clp").unwrap();

    let blocks = ureg_systemrdl::translate_addrmap(addrmap)?;
    for mut block in blocks {
        if block.name.ends_with("_reg") || block.name.ends_with("_csr") {
            block.name = block.name[0..block.name.len() - 4].to_string();
        }
        if block.name == "hmac" {
            remove_reg_prefixes(&mut block.registers, "hmac384_");
        } else {
            remove_reg_prefixes(
                &mut block.registers,
                &format!("{}_", block.name.to_ascii_lowercase()),
            );
        }
        let module_ident = format_ident!("{}", block.name);
        let dest_file = dest_dir.join(format!("{}.rs", block.name));
        let mut block = block.validate_and_dedup()?;

        if block.block().name == "ecc" {
            block.transform(|t| {
                // [TODO]: Put this enumeration into the RDL and remove this hack
                t.set_register_enum(
                    "CTRL",
                    "CTRL",
                    Rc::new(Enum {
                        name: Some("Ctrl".into()),
                        variants: vec![
                            EnumVariant {
                                name: "NONE".into(),
                                value: 0,
                            },
                            EnumVariant {
                                name: "KEYGEN".into(),
                                value: 1,
                            },
                            EnumVariant {
                                name: "SIGNING".into(),
                                value: 2,
                            },
                            EnumVariant {
                                name: "VERIFYING".into(),
                                value: 3,
                            },
                        ],
                        bit_width: 2,
                    }),
                );
            });
        }
        let tokens = ureg_codegen::generate_code(
            &block,
            ureg_codegen::Options {
                module: quote! {#module_ident},
            },
        );
        println!("Writing to {dest_file:?}");
        std::fs::write(&dest_file, header.clone() + &tokens.to_string())?;
        run_cmd(
            Command::new("rustfmt")
                .arg(dest_file)
                .arg("--config=normalize_comments=true,normalize_doc_attributes=true"),
        )?;
    }
    Ok(())
}

fn main() {
    if let Err(err) = real_main() {
        eprintln!("{}", err);
        std::process::exit(1);
    }
}
